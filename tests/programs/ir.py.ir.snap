---
source: tests/snapshots.rs
expression: output
---
def empty():
  bb0:
    return


def single():
  bb0:
    1 + 2
    return


def single_return():
  bb0:
    return 1 + 2


def params(a: {[a, b]}, b: {[b, c]}):
  bb0:
    return a @ b


def if_else_join(a: NonTensor):
  bb0:
    jmp bb1 if a else bb2
  bb2:
    b = 2
    jump bb3
  bb1:
    b = 1
    jump bb3
  bb3:
    return b


def if_else_no_join(a: NonTensor):
  bb0:
    jmp bb1 if a else bb2
  bb2:
    return 1 - 2
  bb1:
    return 1 + 2


def method_vs_func(a: NonTensor):
  bb0:
    torch.ones(1, 2)
    a.reshape(1)
    return


def simple_while(n: NonTensor):
  bb0:
    i = 0
    jump bb1
  bb1:
    jmp bb2 if i < n else bb3
  bb3:
    return i
  bb2:
    i = i + 1
    jump bb1


def simple_for(n: NonTensor):
  bb0:
    total = 0
    jump bb1
  bb1:
    jmp bb2 if ? else bb3
  bb3:
    return total
  bb2:
    total = total + i
    jump bb1


def while_with_if(n: NonTensor):
  bb0:
    i = 0
    jump bb1
  bb1:
    jmp bb2 if i < n else bb3
  bb3:
    return i
  bb2:
    jmp bb4 if i % 2 == 0 else bb5
  bb5:
    i = i + 1
    jump bb6
  bb4:
    i = i + 2
    jump bb6
  bb6:
    jump bb1


def nested_for(n: NonTensor, m: NonTensor):
  bb0:
    total = 0
    jump bb1
  bb1:
    jmp bb2 if ? else bb3
  bb3:
    return total
  bb2:
    jump bb4
  bb4:
    jmp bb5 if ? else bb6
  bb6:
    jump bb1
  bb5:
    total = total + i + j
    jump bb4


def nested_while(n: NonTensor, m: NonTensor):
  bb0:
    i = 0
    j = 0
    jump bb1
  bb1:
    jmp bb2 if i < n else bb3
  bb3:
    return i
  bb2:
    jump bb4
  bb4:
    jmp bb5 if j < m else bb6
  bb6:
    i = i + 1
    j = 0
    jump bb1
  bb5:
    j = j + 1
    jump bb4


def for_with_if(n: NonTensor):
  bb0:
    total = 0
    jump bb1
  bb1:
    jmp bb2 if ? else bb3
  bb3:
    return total
  bb2:
    jmp bb4 if i > 5 else bb5
  bb5:
    total = total + 1
    jump bb6
  bb4:
    total = total + i
    jump bb6
  bb6:
    jump bb1
